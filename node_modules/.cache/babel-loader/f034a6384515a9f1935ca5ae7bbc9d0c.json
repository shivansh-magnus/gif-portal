{"ast":null,"code":"import { inflate } from \"pako\";\nimport { idlAddress, decodeIdlAccount } from \"../idl\";\nimport Coder from \"../coder\";\nimport NamespaceFactory from \"./namespace\";\nimport { getProvider } from \"../\";\nimport { utf8 } from \"../utils/bytes\";\nimport { EventManager } from \"./event\";\nimport { translateAddress } from \"./common\";\nexport * from \"./common\";\nexport * from \"./context\";\nexport * from \"./event\";\nexport * from \"./namespace\";\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/project-serum/anchor#examples).\n */\n\nexport class Program {\n  /**\n   * @param idl       The interface definition.\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context to use. If not provided\n   *                  then uses [[getProvider]].\n   */\n  constructor(idl, programId, provider) {\n    programId = translateAddress(programId);\n\n    if (!provider) {\n      provider = getProvider();\n    } // Fields.\n\n\n    this._idl = idl;\n    this._provider = provider;\n    this._programId = programId;\n    this._coder = new Coder(idl);\n    this._events = new EventManager(this._programId, provider, this._coder); // Dynamic namespaces.\n\n    const [rpc, instruction, transaction, account, simulate, state] = NamespaceFactory.build(idl, this._coder, programId, provider);\n    this.rpc = rpc;\n    this.instruction = instruction;\n    this.transaction = transaction;\n    this.account = account;\n    this.simulate = simulate;\n    this.state = state;\n  }\n  /**\n   * Address of the program.\n   */\n\n\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * IDL defining the program's interface.\n   */\n\n\n  get idl() {\n    return this._idl;\n  }\n  /**\n   * Coder for serializing requests.\n   */\n\n\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Wallet and network provider.\n   */\n\n\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Generates a Program client by fetching the IDL from the network.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n\n\n  static async at(address, provider) {\n    const programId = translateAddress(address);\n    const idl = await Program.fetchIdl(programId, provider);\n\n    if (!idl) {\n      throw new Error(`IDL not found for program: ${address.toString()}`);\n    }\n\n    return new Program(idl, programId, provider);\n  }\n  /**\n   * Fetches an idl from the blockchain.\n   *\n   * In order to use this method, an IDL must have been previously initialized\n   * via the anchor CLI's `anchor idl init` command.\n   *\n   * @param programId The on-chain address of the program.\n   * @param provider  The network and wallet context.\n   */\n\n\n  static async fetchIdl(address, provider) {\n    provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    const programId = translateAddress(address);\n    const idlAddr = await idlAddress(programId);\n    const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n\n    if (!accountInfo) {\n      return null;\n    } // Chop off account discriminator.\n\n\n    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n    const inflatedIdl = inflate(idlAccount.data);\n    return JSON.parse(utf8.decode(inflatedIdl));\n  }\n  /**\n   * Invokes the given callback every time the given event is emitted.\n   *\n   * @param eventName The PascalCase name of the event, provided by the IDL.\n   * @param callback  The function to invoke whenever the event is emitted from\n   *                  program logs.\n   */\n\n\n  addEventListener(eventName, callback) {\n    return this._events.addEventListener(eventName, callback);\n  }\n  /**\n   * Unsubscribes from the given eventName.\n   */\n\n\n  async removeEventListener(listener) {\n    return await this._events.removeEventListener(listener);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["inflate","idlAddress","decodeIdlAccount","Coder","NamespaceFactory","getProvider","utf8","EventManager","translateAddress","Program","constructor","idl","programId","provider","_idl","_provider","_programId","_coder","_events","rpc","instruction","transaction","account","simulate","state","build","coder","at","address","fetchIdl","Error","toString","idlAddr","accountInfo","connection","getAccountInfo","idlAccount","data","slice","inflatedIdl","JSON","parse","decode","addEventListener","eventName","callback","removeEventListener","listener"],"sourceRoot":"","sources":["../../../src/program/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}