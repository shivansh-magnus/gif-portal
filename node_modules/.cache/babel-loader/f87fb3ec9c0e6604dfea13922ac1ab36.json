{"ast":null,"code":"import _toConsumableArray from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/shivanshdwivedi/Desktop/gif-portal-starter/node_modules/@babel/runtime/regenerator/index.js\";\nimport * as assert from \"assert\";\nvar LOG_START_INDEX = \"Program log: \".length;\nexport var EventManager = /*#__PURE__*/function () {\n  function EventManager(programId, provider, coder) {\n    _classCallCheck(this, EventManager);\n\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  _createClass(EventManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, callback) {\n      var _this = this;\n\n      var _a;\n\n      var listener = this._listenerIdCount;\n      this._listenerIdCount += 1; // Store the listener into the event map.\n\n      if (!(eventName in this._eventCallbacks)) {\n        this._eventListeners.set(eventName, []);\n      }\n\n      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener)); // Store the callback into the listener map.\n\n\n      this._eventCallbacks.set(listener, [eventName, callback]); // Create the subscription singleton, if needed.\n\n\n      if (this._onLogsSubscriptionId !== undefined) {\n        return listener;\n      }\n\n      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, function (logs, ctx) {\n        if (logs.err) {\n          console.error(logs);\n          return;\n        }\n\n        _this._eventParser.parseLogs(logs.logs, function (event) {\n          var allListeners = _this._eventListeners.get(event.name);\n\n          if (allListeners) {\n            allListeners.forEach(function (listener) {\n              var listenerCb = _this._eventCallbacks.get(listener);\n\n              if (listenerCb) {\n                var _listenerCb = _slicedToArray(listenerCb, 2),\n                    _callback = _listenerCb[1];\n\n                _callback(event.data, ctx.slot);\n              }\n            });\n          }\n        });\n      });\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(listener) {\n        var callback, _callback2, eventName, listeners;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Get the callback.\n                callback = this._eventCallbacks.get(listener);\n\n                if (callback) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Event listener \".concat(listener, \" doesn't exist!\"));\n\n              case 3:\n                _callback2 = _slicedToArray(callback, 1), eventName = _callback2[0]; // Get the listeners.\n\n                listeners = this._eventListeners.get(eventName);\n\n                if (listeners) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Event listeners don't exist for \".concat(eventName, \"!\"));\n\n              case 7:\n                // Update both maps.\n                this._eventCallbacks.delete(listener);\n\n                listeners = listeners.filter(function (l) {\n                  return l !== listener;\n                });\n\n                if (listeners.length === 0) {\n                  this._eventListeners.delete(eventName);\n                } // Kill the websocket connection if all listeners have been removed.\n\n\n                if (!(this._eventCallbacks.size == 0)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                assert.ok(this._eventListeners.size === 0);\n\n                if (!(this._onLogsSubscriptionId !== undefined)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 15;\n                return this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n\n              case 15:\n                this._onLogsSubscriptionId = undefined;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function removeEventListener(_x) {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }]);\n\n  return EventManager;\n}();\nexport var EventParser = /*#__PURE__*/function () {\n  function EventParser(programId, coder) {\n    _classCallCheck(this, EventParser);\n\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  _createClass(EventParser, [{\n    key: \"parseLogs\",\n    value: function parseLogs(logs, callback) {\n      var logScanner = new LogScanner(logs);\n      var execution = new ExecutionContext(logScanner.next());\n      var log = logScanner.next();\n\n      while (log !== null) {\n        var _this$handleLog = this.handleLog(execution, log),\n            _this$handleLog2 = _slicedToArray(_this$handleLog, 3),\n            event = _this$handleLog2[0],\n            newProgram = _this$handleLog2[1],\n            didPop = _this$handleLog2[2];\n\n        if (event) {\n          callback(event);\n        }\n\n        if (newProgram) {\n          execution.push(newProgram);\n        }\n\n        if (didPop) {\n          execution.pop();\n        }\n\n        log = logScanner.next();\n      }\n    } // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n\n  }, {\n    key: \"handleLog\",\n    value: function handleLog(execution, log) {\n      // Executing program is this program.\n      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n        return this.handleProgramLog(log);\n      } // Executing program is not this program.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs from *this* program.\n\n  }, {\n    key: \"handleProgramLog\",\n    value: function handleProgramLog(log) {\n      // This is a `msg!` log.\n      if (log.startsWith(\"Program log:\")) {\n        var logStr = log.slice(LOG_START_INDEX);\n        var event = this.coder.events.decode(logStr);\n        return [event, null, false];\n      } // System log.\n      else {\n        return [null].concat(_toConsumableArray(this.handleSystemLog(log)));\n      }\n    } // Handles logs when the current program being executing is *not* this.\n\n  }, {\n    key: \"handleSystemLog\",\n    value: function handleSystemLog(log) {\n      // System component.\n      var logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n      if (logStart.match(/^Program (.*) success/g) !== null) {\n        return [null, true]; // Recursive call.\n      } else if (logStart.startsWith(\"Program \".concat(this.programId.toString(), \" invoke\"))) {\n        return [this.programId.toString(), false];\n      } // CPI call.\n      else if (logStart.includes(\"invoke\")) {\n        return [\"cpi\", false]; // Any string will do.\n      } else {\n        return [null, false];\n      }\n    }\n  }]);\n\n  return EventParser;\n}(); // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nvar ExecutionContext = /*#__PURE__*/function () {\n  function ExecutionContext(log) {\n    _classCallCheck(this, ExecutionContext);\n\n    var _a; // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n\n\n    var program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n\n    if (!program) {\n      throw new Error(\"Could not find program invocation log line\");\n    }\n\n    this.stack = [program];\n  }\n\n  _createClass(ExecutionContext, [{\n    key: \"program\",\n    value: function program() {\n      assert.ok(this.stack.length > 0);\n      return this.stack[this.stack.length - 1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(newProgram) {\n      this.stack.push(newProgram);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert.ok(this.stack.length > 0);\n      this.stack.pop();\n    }\n  }]);\n\n  return ExecutionContext;\n}();\n\nvar LogScanner = /*#__PURE__*/function () {\n  function LogScanner(logs) {\n    _classCallCheck(this, LogScanner);\n\n    this.logs = logs;\n  }\n\n  _createClass(LogScanner, [{\n    key: \"next\",\n    value: function next() {\n      if (this.logs.length === 0) {\n        return null;\n      }\n\n      var l = this.logs[0];\n      this.logs = this.logs.slice(1);\n      return l;\n    }\n  }]);\n\n  return LogScanner;\n}();","map":{"version":3,"mappings":"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","names":["assert","LOG_START_INDEX","length","EventManager","programId","provider","coder","_programId","_provider","_eventParser","EventParser","_eventCallbacks","Map","_eventListeners","_listenerIdCount","eventName","callback","listener","set","get","_a","concat","_onLogsSubscriptionId","undefined","connection","onLogs","logs","ctx","err","console","error","parseLogs","event","allListeners","name","forEach","listenerCb","data","slot","Error","listeners","delete","filter","l","size","ok","removeOnLogsListener","logScanner","LogScanner","execution","ExecutionContext","next","log","handleLog","newProgram","didPop","push","pop","stack","program","toString","handleProgramLog","handleSystemLog","startsWith","logStr","slice","events","decode","logStart","split","match","includes","exec"],"sourceRoot":"","sources":["../../../src/program/event.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}